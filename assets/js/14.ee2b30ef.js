(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{471:function(t,e,a){"use strict";a.r(e);var v=a(21),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"哈希表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哈希表"}},[t._v("#")]),t._v(" 哈希表")]),t._v(" "),a("blockquote",[a("p",[t._v("散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。")])]),t._v(" "),a("h3",{attrs:{id:"空间换时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#空间换时间"}},[t._v("#")]),t._v(" 空间换时间")]),t._v(" "),a("p",[t._v("先来看一个简单的问题：给定一个正整数序列"),a("code",[t._v("A = {8,3,4,7,2}")]),t._v("，再给定一个正整数x，判断x是否在A中出现过。对于每个x，我们都需要遍历序列A，查找的时间复杂度为O(n)。为了节省查找时间，我们不妨用空间换时间，即设定一个bool型数组hashTable[MAX]，其中"),a("code",[t._v("hashTable[x] == true")]),t._v("表示正整数x在A中出现过：")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[t._v("0")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("1")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("2")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("3")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("4")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("5")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("6")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("7")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("8")]),t._v(" "),a("th",{staticStyle:{"text-align":"center"}},[t._v("...")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[t._v("false")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("false")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("true")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("true")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("true")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("false")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("false")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("true")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("true")]),t._v(" "),a("td",{staticStyle:{"text-align":"center"}},[t._v("...")])])])]),t._v(" "),a("p",[t._v("由此我们可以快速的判断正整数x是否在序列A中，查找的时间复杂度降为O(1)。"),a("strong",[t._v("空间换时间")]),t._v("是非常实用的算法思想之一，哈希表就是此思想的经典应用。")]),t._v(" "),a("h3",{attrs:{id:"散列函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#散列函数"}},[t._v("#")]),t._v(" 散列函数")]),t._v(" "),a("p",[t._v("一般来说，散列即"),a("strong",[t._v("将元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素")]),t._v("。其中，这个转换函数称为"),a("strong",[t._v("散列函数H")]),t._v("，元素为key，那么转换后就是一个整数H(key)。常用的散列函数有：")]),t._v(" "),a("ul",[a("li",[t._v("直接定址法")]),t._v(" "),a("li",[t._v("平方取中法")]),t._v(" "),a("li",[t._v("除留余数法")])]),t._v(" "),a("h3",{attrs:{id:"哈希冲突"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哈希冲突"}},[t._v("#")]),t._v(" 哈希冲突")]),t._v(" "),a("p",[t._v("散列函数只能尽量唯一地代表一个元素，可能会存在H(key1)与H(key2)是相同的，当key1已经占走此单元，key2便无法再使用这个位置，这种情况叫做“冲突”。常见的解决冲突的方式有：")]),t._v(" "),a("ul",[a("li",[t._v("开放定址法\n"),a("ul",[a("li",[t._v("线性探查法")]),t._v(" "),a("li",[t._v("平方探查法")])])]),t._v(" "),a("li",[t._v("链地址法")])]),t._v(" "),a("h3",{attrs:{id:"使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[t._v("#")]),t._v(" 使用")]),t._v(" "),a("p",[t._v("一般来说，可以直接通过标准模板库中"),a("RouterLink",{attrs:{to:"/pages/2ac963/#set"}},[t._v("set")]),t._v("和"),a("RouterLink",{attrs:{to:"/pages/2ac963/#map"}},[t._v("map")]),t._v("来直接使用hash的功能。")],1),t._v(" "),a("h2",{attrs:{id:"相关问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相关问题"}},[t._v("#")]),t._v(" 相关问题")]),t._v(" "),a("p",[a("RouterLink",{attrs:{to:"/pages/bb5871/"}},[t._v("哈希表专题")])],1)])}),[],!1,null,null,null);e.default=_.exports}}]);