---
title: 回溯算法
date: 2021-06-19 16:34:17
permalink: /pages/bca1c0/
---

## 回溯算法
回溯算法（Back Tracking）实际上是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。通常适用于求解排列组合、所有路径等问题。

一般解题步骤：
1. 针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解
2. 确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间
3. 以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索

## 回溯法的递归模板使用
### 递归模板
许多复杂的，规模较大的问题都可以使用回溯法，故该算法有“通用解题方法”的美称。而在一般情况下，使用递归函数来实现回溯法比较简单，以下是伪代码版的递归模板：
```
void backtracking(已选路径, 可选列表)
{
    if(满足解条件) {
        添加结果路径;
        return;
    }
    for(可选列表) {  // 根据情况可在此处进行剪枝优化
        if(节点符合要求) {  // 可选，在for循环不方便剪枝的情况下使用
            选择节点;
            backTracking(新的已选路径, 可选列表);
            撤销选择;
        }
    }
}
```
### 【例】返回某数组（无重复元素）的所有子集
以下从一个例子来理解此递归模板的使用：
>如给定一个不包含重复元素的数组`nums = [1,2,3]`，应返回其所有子集为`[[],[1],[1,2],[1,2,3],[1,3],[2,3],[3]]`

将遍历过程抽象为树形结构，如下所示：
![](https://gitee.com/einsier/pics-bed/raw/master/pics/2021‎0‎6‎‎20‎‏‎145142.jpg)
该树中每一个节点所经过的路径即为我们所要求的子集。

根据模板完成代码实现：
```cpp
/* 为方便理解代码，结果集res为全局变量（也可放入参数列表） */
void backtracking(vector<int>& path, vector<int>& nums, int idx){
    res.push_back(temp);  // 此处无需判断条件，因为每一个节点都是我们要的解
    
    for(int i = idx; i< nums.size(); ++i) {  // 剩余的元素是可选的
        path.push_back(nums[i]);
        backtracking( path, nums, i + 1);
        path.pop_back();
    }
}
```

### 小结
针对回溯算法相关问题，通常我们可以按照以下步骤求解：
1. 根据题意将遍历过程抽象为树形结构
2. 确定解边界条件和剪枝优化过程
3. 根据递归模板完成代码

## 相关问题
[回溯算法专题](/pages/fde77d/)