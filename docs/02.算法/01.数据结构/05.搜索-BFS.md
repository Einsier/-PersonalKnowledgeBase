---
title: 搜索-BFS
date: 2021-06-25 19:17:30
permalink: /pages/c635ec/
---

## 广度优先搜索（BFS）
深度优先搜索（Depth First Search，DFS）和广度优先搜索（Breadth First Search，BFS）是图论中两种重要的搜索算法。其中，BFS是以**广度**为第一关键词，总是先依次访问从当前结点能直接访问的**所有**结点，然后再按照这些结点被访问的顺序去依次访问它们能直接到达的所有节点，以此类推，直到所有的结点都被访问为止。

BFS的主要思想类似于树的层序遍历。常用于求解最少步数问题。

## 单向BFS
单向BFS即为最普通的BFS搜索，从一个初始结点出发，通过BFS搜索直到找到目标结点。BFS一般由[队列](/pages/fd9bd8/#队列)实现，以下图为例：
![](https://gitee.com/einsier/pics-bed/raw/master/pics/‎2021‎0‎6‎28145437.jpg)

若A为起始点，搜索目标E，其过程为：
1. 将起点A入队，此时队列元素为{A}
2. 队首元素A出队，并将与A直接相连的B、C入队，此时队列元素为{B、C}
3. 队首元素B出队，并将与B直接相连的D入队，此时队列元素为{C、D}
4. 队首元素C出队，并将与C直接相连的E入队，此时队列元素为{D、E}
5. 队首元素D出队，并将与D直接相连的F入队，此时队列元素为{E、F}
6. 队首元素E出队，找到目标结点，算法结束

由此可以得出BFS的代码模板：
```cpp
void BFS(int start) {
    queue<int> q;
    q.push(start);
    起始点设置为已入队;
    while(!q.empty()) {
        访问队首元素;  // 可做任何操作
        队首元素出队;
        将队首元素下一层结点中未曾入队的结点全部入队，并设置为已入队;
    }
}
```
由以上代码可知，为了防止走回头路，一般需要设置一个数组或哈希表来记录每个结点**是否在BFS中已入过队**。除此之外，BFS通常用来求解最少步数问题，即为在到达目标结点时的层数，于是可以根据BFS的特性在上述代码基础上加上层数的计算：
```cpp {7-8,12}
int BFS(int start) {
    int res = 0;  // 起始结点步数为0
    queue<int> q;
    q.push(start);
    起始点设置为已入队;
    while(!q.empty()) {
        for(int i = 0, len = q.size(); i < len; ++i) {  // 遍历当前层数所有结点
            if(队首结点为目标结点) return res;
            队首元素出队;
            将队首元素下一层结点中未曾入队的结点全部入队，并设置为已入队;
        }
        ++res;
    }
    return -1;
}
```

## 双向BFS
> 待更新

## 相关问题
[BFS专题](/pages/9de987/)